Use cases
=========

Kernel developers
-----------------

* make defconfig ; make prepare ; make deb-pkg -> test .deb
* test foreign architectures (qemu-system-$ARCH)

Software developers
-------------------

* test supported command line options and all their combinations
* execute commands with different input files
* run (graphical and console based) interfaces with automated tests
* stress test and fuzzy test programs/kernel (crashme)
* performance testing (note: might not be the best choice using VMs but performance graphs might help in detecting
serious regressions)
* test with different system environments (facked time -> datefudge,...)

Debian packagers
----------------

* test installation and removal of specific package(s) (local and from the Debian pool)
* different suites (stable/testing/unstable) and with different repositories (backports,
volatile,...)

Non-Debian developers
---------------------

* test different distributions

Administrators
--------------

* test services (database, mailserver, samba [samba4-testsuite],...)
* test deployments (FAI, d-i, puppet [puppet-testsuite],...)
* test complex scenarios (HA/cluster/...)
* test network access

Testers
-------

* verify existing documentation
* test software and write according documentation
* verify specific use cases and reproduce bugreports

Resulting requirements
======================

* live system as option but not as requirement, e.g. to test kernels and initrd without the rest
* support different architectures (kvm for the common cases but qemu as fallback for non-native archs)
* live systems should:
  - provide information about bootstrapped environment (stable vs. testing vs...)
  - provide a way to automatically download and execute scripts (using kernel cmdline)
  - use one of just few implementations for building initramfs (initramfs-tools, dracut,...)
